# 费马小定理

**内容：**

若存在整数 a , p 且gcd(a,p)=1,即二者互为质数，则有a^(p-1)≡ 1(mod p)。

**推论：**

当a<p时，a^p≡a(mod p)

一个a^(p-1)模p得到1，则a个a^(p-1) （即a^p）模p得到a



**相关题目：**

[2018CCPC网络赛Dream](https://vjudge.csgrandeur.cn/contest/514122#problem/C)

需要重新定义乘和加的操作，使得 (m+n)^p=m^p+n^p

根据费马小定理：

( m + n )^p ≡ ( m + n ) ( m o d p )

m^p + n^p ≡ m (mod p) + n (mod p) 

因为 ( m + n ) ( m o d p ) ≡ m (mod p) + n (mod p) 

所以 ( m + n )^p ≡ m^p + n^p   (mod p)

因此，在进行所有运算时都%p即可满足题目要求



对于题目中要求集合相等的证明，需要用到**阶与原根**的知识





# 树链剖分

回顾乐树链剖分，并用树链剖分解决最近公共祖先

~~~c++
#include<bits/stdc++.h>
#define ll unsigned long long
#define re register int
using namespace std;
const int maxn=500005;
inline ll read()
{
    ll x=0,f=1;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
    return x*f;
}
int n,m,s;
int tot;
struct node//链式前向星存图
{
    ll to,nex;
}e[maxn<<1];ll head[maxn<<1],cnt;
//***************************完美的框框****************************************
//数组下标是点的序号                                                          
ll d[maxn];//该点的深度                                                   
ll size[maxn];//该点子树点的个数（包括自己）                               
ll fa[maxn];//该点的父节点                                                     
ll son[maxn];//该点的重儿子
//dfs1要用的数组                                                 
//*****************************************************************************
//数组下标是点的序号                                 
ll id[maxn];// 该点再新序列的编号                    
ll top[maxn];// 该点分链上的顶节点(具体可看YTT大佬博客) 
//dfs2要用的数组                             
//******************************************************* 
inline void add(int x,int y)
{
    e[++cnt].to=y;
    e[cnt].nex=head[x];
    head[x]=cnt;
}
inline void dfs1(int x,int f,int deep)
{//dfs1求出每个点的父亲，深度，子树大小 和 根节点最大子树 
    d[x]=deep;
    fa[x]=f;
    size[x]=1;
    for(re i=head[x];i;i=e[i].nex)
    {
        int y=e[i].to;
        if(y==f)continue;
        dfs1(y,x,deep+1);
        size[x]+=size[y];
        if(size[son[x]]<size[y])
        {
            son[x]=y;
        }
    }
    return;
}
inline void dfs2(int x,int top_)
{//dfs2求出 每个点分链上的顶节点(具体可看YTT大佬博客) 并 构建新序列 
    id[x]=++tot;
    top[x]=top_;
    if(!son[x])return;
    dfs2(son[x],top_);
    for(re i=head[x];i;i=e[i].nex)
    {
        int y=e[i].to;
        if(!id[y])dfs2(y,y);
    }
    return;
}
inline int tree_ask(int x,int y)
{//两个点向上跳，直到跳到同一分链
    while(top[x]!=top[y])
    {
        if(d[top[x]]>=d[top[y]])x=fa[top[x]];
        else y=fa[top[y]];
    }
    return d[x]<d[y]?x:y;
}
int main()
{
    n=read();m=read();s=read();
    for(re i=1;i<n;i++)
    {
        int x=read(),y=read();
        add(x,y);add(y,x);
    }
    dfs1(s,0,1);
    dfs2(s,s);
    for(re i=1;i<=m;i++)
    {
        int a=read(),b=read();
        printf("%d\n",tree_ask(a,b));
    }
    return 0;
}
~~~

