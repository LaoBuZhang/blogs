图论



## 拓扑排序

[P4017 最大食物链计数 - 洛谷](https://www.luogu.com.cn/problem/P4017)

记录入度出度，并且向后累加

~~~c++
#include<bits/stdc++.h>
#define ll long long
#define inf 0x3f3f3f3f
#define mod 80112002

using namespace std;
int n,m;
struct node
{
	int to;
	int nex;
}e[500005];
int head[500005];
int cnt;
void add(int a,int b)
{
	e[++cnt].to=b;
	e[cnt].nex=head[a];
	head[a]=cnt;
}
int ru[5005];
int chu[5005];
int f[5005];
queue<int>q;
int ans;

int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int a,b;
		cin>>a>>b;
		add(a,b);
		ru[b]++;
		chu[a]++;
	}
	for(int i=1;i<=n;i++)
	{
		if(ru[i]==0)
		{
			q.push(i);
			f[i]=1;
		}
	}
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=e[i].nex)
		{
			int y=e[i].to;
			f[y]=(f[y]+f[x])%mod;
			ru[y]--;
			if(ru[y]==0)
			{
				q.push(y);
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(chu[i]==0)
		{
			ans=(ans+f[i])%mod;
		}
	}
	cout<<ans;
	return 0;
}
~~~





## 最短路

### 单源最短路



**【模板】单源最短路径（标准版）**

[题目链接](https://www.luogu.com.cn/problem/P4779)

**题目描述**

给定一个 n 个点，m 条有向边的带非负权图，请你计算从 s 出发，到每个点的距离。

数据保证你能从 s 出发到任意点。

**输入格式**

第一行为三个正整数 n, m, s。
第二行起 m 行，每行三个非负整数 u_i, v_i, w_i，表示从 u_i 到 v_i 有一条权值为 w_i 的有向边。

**输出格式**

输出一行 n 个空格分隔的非负整数，表示 s 到每个点的距离。

**样例输入 #1**

```
4 6 1
1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4
```

**样例输出 #1**

```
0 2 4 3
```



#### dijkstra

~~~c++
#include<bits/stdc++.h>
#define ll long long
#define inf 0x3f3f3f3f

using namespace std;
int n,m,s;
struct node
{
	int pro;
	int to;
	int nex;
	int v;
}e[200005];
int head[200005];
int cnt;
void add(int a,int b,int c)
{
	e[++cnt].pro=a;
	e[cnt].to=b;
	e[cnt].v=c;
	e[cnt].nex=head[a];
	head[a]=cnt;
}

int d[100005];
int v[100005];
priority_queue<pair<int,int> >q;
void dijkstra(int be)
{
	memset(d,0x3f,sizeof(d));
	d[be]=0;
	q.push({0,be});
	while(!q.empty())
	{
		int x=q.top().second;
		q.pop();
		if(v[x])continue;
		v[x]=1;
		for(int i=head[x];i;i=e[i].nex)
		{
			int y=e[i].to;
			int z=e[i].v;
			if(d[y]>d[x]+z)
			{
				d[y]=d[x]+z;
				q.push({-d[y],y});
			}
		}
	}
}

int main()
{
	cin>>n>>m>>s;
	for(int i=1;i<=m;i++)
	{
		int a,b,c;
		cin>>a>>b>>c;
		add(a,b,c); 
	}
	dijkstra(s);
	for(int i=1;i<=n;i++)
	{
		cout<<d[i]<<" ";
	}
	return 0;
}
~~~



##### priority_queue实现最小堆

priority_queue默认为大根堆

若要实现小根堆，则需要下列操作

1. 自定义结构体

   ~~~c++
   struct node
   {
       int id;
       double value;
   };
   bool operator <(const node &a,const node &b)
   {
       return a.value>b.value;
   }
   ~~~

2. 修改参数

   第一个参数T：元素（element）类型
   第二个参数Container：必须是容器类型Container，用来存储元素（element），其类型必须是第一个参数
   第三个参数Compare：比较形式，默认是less

   ~~~c++
   priority_queue<pair<int,int> ,vector<pair<int,int> >,greater<pair<int,int> > >q;//小根堆
   
   priority_queue<pair<int,int> ,vector<pair<int,int> >,less<pair<int,int> > >q;//大根堆（默认）
   ~~~

   





#### Bellman-ford和SPFA

~~~c++
#include<bits/stdc++.h>
#define ll long long
#define inf 0x3f3f3f3f

using namespace std;
int n,m,s;
struct node
{
	int to;
	int nex;
	int v;
}e[500005];
int head[500005];
int cnt;
void add(int a,int b,int c)
{
	e[++cnt].to=b;
	e[cnt].v=c;
	e[cnt].nex=head[a];
	head[a]=cnt;
}
int d[10005];
int v[10005];
queue<int>q;
void spfa(int be)
{
	memset(d,0x3f,sizeof(d));
	memset(v,0,sizeof(v));
	d[be]=0;
	v[be]=1;
	q.push(be);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		v[x]=0;
		for(int i=head[x];i;i=e[i].nex)
		{
			int y=e[i].to;
			int z=e[i].v;
			if(d[y]>d[x]+z)
			{
				d[y]=d[x]+z;
				if(!v[y])
				{
					q.push(y);
					v[y]=1;	
				}
			}
		}
	}
}

int main()
{
	cin>>n>>m>>s;
	for(int i=1;i<=m;i++)
	{
		int a,b,c;
		cin>>a>>b>>c;
		add(a,b,c);
	}
	spfa(s);
	for(int i=1;i<=n;i++)
	{
		cout<<d[i]<<" ";
	}
	return 0;
}
~~~



### 任意两点间最短路

#### floyd算法

~~~c++
for(int k=1;k<=n;k++)
{
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
        }
    }
}
~~~





##### 传递闭包问题

给定若干对元素和若干对二元关系，且关系具有传递性，通过传递性推导出尽可能多的元素之间的关系

d\[i\]\[j\]=1表示i与j有关系，d\[i\]\[j\]=0表示i与j没有关系，特别的d\[i\]\[i\]=1

~~~c++
for(int k=1;k<=n;k++)
{
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            d[i][j]|=d[i][k] & d[k][j];
        }
    }
}
~~~





##### 无向图的最小环问题



**Sightseeing trip**

[题目链接](https://vjudge.csgrandeur.cn/contest/506494#problem/C)

**题目描述：**
在Adelton城有一个桑给巴尔岛的旅行社。它已决定提供它的客户，其中一些景点，观光小镇。为了赚取尽可能多的钱，该机构接受了一个精明的决定：有必要找到最短的路线，开始和结束在同一个地方。你的任务是写一个程序，找到这样的路线。
镇上有n个景点，编号从1到N和M个双向道路编号从1到M。
两个景点可以通过多条道路连接，但没有道路连接本身景点。每一条观光路线是一个有序的道路编号，道路数k大于2。观光路线是无重复景点的环路。观光路线的长度是所有路线长度之和。您的程序必须找到长度最小的观光路线，或指定它是不可能的。

**样例输入:**

~~~
5 7
1 4 1
1 3 300
3 1 10
1 2 16
2 3 100
2 5 15
5 3 20
~~~

**样例输出：**

~~~
1 3 5 2
~~~



**思路**

floyd算法通过d\[i\]\[j\] + map\[i\]\[k\] + map\[k\]\[j\] < mi求最小环

同时记录最短路的路径

每次更新最小环时都用最短路路径更新答案路径



~~~c++
#include<iostream>
#include<algorithm>
#include<queue>
#include<string.h>
#define ll long long
#define inf 0xfffffff
//本题使用0x3f3f3f3f会WA，数据会超过0x3f3f3f3f

using namespace std;
int n,m;
int map[105][105];//邻接表记录路径 
int d[105][105];//记录最小路径长度 
int path[105][105];//path[i][j]表示i到j最短路径上的j前面的一个点 
int ans[105];
int mi;
int cnt;

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			d[i][j]=inf;
			map[i][j]=inf;
			path[i][j]=i;
		}
	}
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;
		d[x][y]=d[y][x]=min(d[x][y],z);
		map[x][y]=map[y][x]=min(map[x][y],z);
	}
	mi=inf;
	for(int k=1;k<=n;k++)
	{
		for(int i=1;i<k;i++)
		{
			for(int j=1;j<i;j++)
			{
				if(d[i][j]+map[i][k]+map[k][j]<mi)
				{
					mi=d[i][j]+map[i][k]+map[k][j];
					int tmp=j;
					cnt=0;
					while(tmp!=i)
					{
						ans[cnt++]=tmp;
						tmp=path[i][tmp];
					}
					ans[cnt++]=i;
					ans[cnt++]=k;
				}
			}
		}
		
		//floyd求最短路
		//同时记录最短路路径
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				if(d[i][j]>d[i][k]+d[k][j])
				{
					d[i][j]=d[i][k]+d[k][j];
					path[i][j]=path[k][j];
				}
			}
		}
	}
	if(mi==inf)
	{
		cout<<"No solution.";
	}
	else
	{
		for(int i=0;i<cnt;i++)
		{
			cout<<ans[i]<<" ";
		}
	}
	return 0;
}
~~~





### 次短路

先求1到每个点最短路d1

再求n到每个点最短路d2

遍历每一条边，寻找大于d1[n]的最短d1[x]+d2[y]+z;

~~~c++
ll ans=inf;
ll l=d1[n];
for(int i=1;i<=cnt;i++)
{
    int x=e[i].pro;
    int y=e[i].to;
    int z=e[i].v;
    if(d1[x]+d2[y]+z>l)
    {
        ans=min(ans,d1[x]+d2[y]+z);
    }
}
cout<<ans;
~~~



## 最小生成树



**【模板】最小生成树**

[题目链接](https://www.luogu.com.cn/problem/P3366)

**题目描述**

如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 `orz`。

**输入格式**

第一行包含两个整数 N,M，表示该图共有 N 个结点和 M 条无向边。

接下来 M 行每行包含三个整数 X_i,Y_i,Z_i，表示有一条长度为 Z_i 的无向边连接结点 X_i,Y_i。

**输出格式**

如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 `orz`。

**样例输入 #1**

```
4 5
1 2 2
1 3 2
1 4 3
2 3 4
3 4 3
```

**样例输出 #1**

```
7
```

### kruskal算法

~~~c++
#include<bits/stdc++.h>
#define ll long long
#define inf 0x3f3f3f3f

using namespace std;
int n,m;
int ans;
struct node
{
	int x;
	int y;
	int z;
}e[200005];
bool operator <(node a,node b)
{
	return a.z<b.z;
}
int fa[5005];
int get(int x)
{
	return fa[x]==x?x:fa[x]=get(fa[x]); 
}
void add(int a,int b)
{
	fa[get(a)]=get(fa[b]);
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>e[i].x>>e[i].y>>e[i].z;
	}
	sort(e+1,e+1+m);
	for(int i=1;i<=n;i++)fa[i]=i;
	for(int i=1;i<=m;i++)
	{
		int x=get(e[i].x);
		int y=get(e[i].y);
		int z=e[i].z;
		if(x==y)continue;
		else
		{
			add(x,y);
			ans+=z;
		}
	}
	int flag=0;
	for(int i=1;i<=n;i++)
	{
		if(fa[i]==i)flag++;
	}
	if(flag!=1)
	{
		cout<<"orz";
		return 0;
	}
	cout<<ans;
	return 0;
}
~~~



### prim算法

~~~c++
#include<bits/stdc++.h>
#define ll long long
#define inf 0x3f3f3f3f

using namespace std;

int a[5005][5005];
int d[5005];//d[i]表示i被加入生成树时选出的最小边的权值
int n,m,ans;
bool v[5005];

void prim()
{
	memset(d,0x3f,sizeof(d));
	memset(v,0,sizeof(v));
	d[1]=0;
	for(int i=1;i<n;i++)
	{
		int x=0;
		for(int j=1;j<=n;j++)
		{
			if(!v[j]&&(x==0||d[j]<d[x]))x=j;
		}
		v[x]=1;
		for(int y=1;y<=n;y++)
		{
			if(!v[y])
			{
				d[y]=min(d[y],a[x][y]);
			}
		}
	}
}

int main()
{
	cin>>n>>m;
	memset(a,0x3f,sizeof(a));
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		a[y][x]=a[x][y]=min(a[x][y],z);
	}
	prim();
	for(int i=1;i<=n;i++)
	{
		if(d[i]==inf)
		{
			cout<<"orz"<<endl;
			return 0;
		}
	}
	for(int i=2;i<=n;i++)
	{
		ans+=d[i];
	}
	cout<<ans<<endl;
	return 0;
}
~~~





## 树的直径

树中最远的两个节点之间的距离

### 树形DP求树的直径

设1号节点为根

d[x]表示从节点x出发走向以x为跟的子树，能够到达的最远的节点的距离，设x的子节点为y1,y2,...,yt ,  edge(x,y)表示边权

则：d[x]=max ( d [ y_i ] , edge ( x , y_i ) ) ;



f[x]表示经过节点x的最长链的长度

则：f[x]=max( d[ y_i ] + edge( x , y_i ) + d[ y_j ] + edge( x , y_j) );

树的直径就是 max( f[x] )



我们没有必要用两层循环枚举i和j

在计算d[x]时，当枚举到i时，d[x]保存的就是max ( d [ y_j ] , edge ( x , y_j ) )    (j<i)

所以此时先用d[x]+d[ y_i ]+edge( x , y_i ) 更新f[x]，在用d[ y_i ]+edge( x , y_i )更新d[x]



~~~c++
void dp(int x)
{
    v[x]=1;
    for(int i=head[x];i;i=e[i].next)
    {
        int y=e[i].to;
        if(v[y])continue;
        dp(y);
        ans=max(ans,d[x]+d[y]+e[i].v);
        d[x]=max(d[x],d[y]+e[i].v);
    }
}
~~~



### 两次BFS求树的直径

1. 从任意一个节点出发，通过bfs（或者dfs）对树进行一次遍历，求出与出发点距离最远的节点，记为p
2. 从p节点出发，通过dfs或者dfs求出与p距离最远的节点，几位q
3. 从p到q的路径就是树的一条直径
4. 在第二步的过程中，可以记录下来每个点第一次被访问时的前驱节点，最后可以递归得到直径的具体方案



[P5536 【XR-3】核心城市](https://www.luogu.com.cn/problem/P5536)

~~~c++
#include<bits/stdc++.h>
#define ll long long
#define inf 0x3f3f3f3f

using namespace std;
int n,k;

struct node
{
	int to;
	int next;
}e[200005];
int head[100005];
int cnt;
void add(int a,int b)
{
	e[++cnt].to=b;
	e[cnt].next=head[a];
	head[a]=cnt;
}

int p;
int v[100005];
int maxn=0;
void dfs1(int x,int len)
{
	if(len>maxn)
	{
		maxn=len;
		p=x;
	}
	for(int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if(!v[y])
		{
			v[y]=1;
			dfs1(y,len+1);
		}
	}
}

int q;
int pre[100005];
void dfs2(int x,int len)
{
	if(len>maxn)
	{
		maxn=len;
		q=x;
	}
	for(int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if(!v[y])
		{
			v[y]=1;
			pre[y]=x;
			dfs2(y,len+1);
		}
	}
}

int deep[100005];
int maxdeep[100005];
int ans[100005];
void dfs_k(int x)
{
	maxdeep[x]=deep[x];
	for(int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if(!v[y])
		{
			v[y]=1;
			deep[y]=deep[x]+1;
			dfs_k(y);
			maxdeep[x]=max(maxdeep[x],maxdeep[y]);
		}
	}
}

bool cmp(int a,int b)
{
	return a>b;
}

int main()
{
	cin>>n>>k;
	for(int i=1;i<n;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		add(a,b);
		add(b,a);
	}
	
	v[1]=1;
	dfs1(1,0);
	
	memset(v,0,sizeof(v));
	v[p]=1;
	maxn=0;
	dfs2(p,0);
	
	int mid=q;
	maxn++;//直径长度
	for(int i=1;i<=(maxn)/2;i++)
	{
		mid=pre[mid];
	}
	
	memset(v,0,sizeof(v));
	v[mid]=1;
	dfs_k(mid);
	
	for(int i=1;i<=n;i++)
	{
		ans[i]=maxdeep[i]-deep[i];
	}
	sort(ans+1,ans+1+n,cmp);
	
	int ans_k=0;
	for(int i=k+1;i<=n;i++)
	{
		ans_k=max(ans_k,ans[i]+1);
	}
	cout<<ans_k;
	
	return 0;
}
~~~



## 最近公共祖先



**【模板】最近公共祖先（LCA）**

[题目链接](https://www.luogu.com.cn/problem/P3379)

**题目描述**

如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。

**输入格式**

第一行包含三个正整数 N,M,S，分别表示树的结点个数、询问的个数和树根结点的序号。

接下来 N-1 行每行包含两个正整数 x, y，表示 x 结点和 y 结点之间有一条直接连接的边（数据保证可以构成树）。

接下来 M 行每行包含两个正整数 a, b，表示询问 a 结点和 b 结点的最近公共祖先。

**输出格式**

输出包含 M 行，每行包含一个正整数，依次为每一个询问的结果。

**样例输入 #1**

```
5 5 4
3 1
2 4
5 1
1 4
2 4
3 2
3 5
1 2
4 5
```

**样例输出 #1**

```
4
4
1
4
4
```



### 树上倍增法

~~~c++
#include<bits/stdc++.h>
#define ll long long
#define inf 0x3f3f3f3f

using namespace std;
int n,m,s;
struct node
{
	int pro;
	int to;
	int nex;
}e[1000005];
int head[1000005];
int cnt;
void add(int a,int b)
{
	e[++cnt].to=b;
	e[cnt].pro=a;
	e[cnt].nex=head[a];
	head[a]=cnt;
}

int f[500005][20];
int d[500005];
int t;

queue<int>q;
void bfs(int root)
{
	q.push(root);
	d[root]=1;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=e[i].nex)
		{
			int y=e[i].to;
			if(d[y])continue;
			d[y]=d[x]+1;
			f[y][0]=x;
			for(int j=1;j<=t;j++)
			{
				f[y][j]=f[f[y][j-1]][j-1];
			}
			q.push(y);
		}
	}
}
int lca(int x,int y)
{
	if(d[x]>d[y])swap(x,y);
	for(int i=t;i>=0;i--)
	{
		if(d[f[y][i]]>=d[x])y=f[y][i];
	}
	if(x==y)return x;
	for(int i=t;i>=0;i--)
	{
		if(f[x][i]!=f[y][i])
		{
			x=f[x][i];
			y=f[y][i];
		}
	}
	return f[x][0];
}
int main()
{
	cin>>n>>m>>s;
	t=log(n)/log(2)+1;
	for(int i=1;i<n;i++)
	{
		int a,b;
		cin>>a>>b;
		add(a,b);
		add(b,a);
	}
	bfs(s);
	for(int i=1;i<=m;i++)
	{
		int a,b;
		cin>>a>>b;
		cout<<lca(a,b)<<endl;
	}
	return 0;
}
~~~



### *树链剖分求lca

~~~c++
#include<bits/stdc++.h>
#define ll  long long
#define re register int
using namespace std;
const int maxn=500005;

int n,m,s;
int tot;

struct node
{
    ll to;
	ll nex;
}e[maxn<<1];
ll head[maxn<<1];
ll cnt;
void add(ll x,ll y)
{
    e[++cnt].to=y;
    e[cnt].nex=head[x];
    head[x]=cnt;
}
                                                       
ll d[maxn];//该点的深度
ll size[maxn];//该点子树点的个数（包括自己）
ll fa[maxn];//该点的父节点
ll son[maxn];//该点的重儿子
void dfs1(int x,int f,int deep)
{
    d[x]=deep;
    fa[x]=f;
    size[x]=1;
    for(int i=head[x];i;i=e[i].nex)
    {
        int y=e[i].to;
        if(y==f)continue;
        dfs1(y,x,deep+1);
        size[x]+=size[y];
        if(size[son[x]]<size[y])
        {
            son[x]=y;
        }
    }
}


ll id[maxn];// 该点再新序列的编号
ll top[maxn];// 该点分链上的顶节点
void dfs2(int x,int top_)
{//dfs2求出 每个点分链上的顶节点并构建新序列
    id[x]=++tot;
    top[x]=top_;
    if(son[x]==0)return;
    dfs2(son[x],top_);
    for(int i=head[x];i;i=e[i].nex)
    {
        int y=e[i].to;
        if(!id[y])dfs2(y,y);
    }
}

int tree_ask(int x,int y)
{//两个点向上跳，直到跳到同一分链
    while(top[x]!=top[y])
    {
        if(d[top[x]]>=d[top[y]])x=fa[top[x]];
        else y=fa[top[y]];
    }
    return d[x]<d[y]?x:y;
}
int main()
{
    n=read();m=read();s=read();
    for(re i=1;i<n;i++)
    {
        int x=read(),y=read();
        add(x,y);add(y,x);
    }
    dfs1(s,0,1);
    dfs2(s,s);
    for(re i=1;i<=m;i++)
    {
        int a=read(),b=read();
        printf("%d\n",tree_ask(a,b));
    }
    return 0;
}
~~~





### lca的tarjan算法



## 树上差分



## 次小生成树



## 基环树



## 负环



**【模板】负环**

[题目链接](https://www.luogu.com.cn/problem/P3385)

**题目描述**

给定一个 n 个点的有向图，请求出图中是否存在**从顶点 1 出发能到达**的负环。

负环的定义是：一条边权之和为负数的回路。

**输入格式**

**本题单测试点有多组测试数据**。

输入的第一行是一个整数 T，表示测试数据的组数。对于每组数据的格式如下：

第一行有两个整数，分别表示图的点数 n 和接下来给出边信息的条数 m。

接下来 m 行，每行三个整数 u, v, w。

- 若 w >= 0，则表示存在一条从 u 至 v 边权为 w 的边，还存在一条从 v 至 u 边权为 w 的边。
- 若 w < 0，则只表示存在一条从 u 至 v 边权为 w 的边。

**输出格式**

对于每组数据，输出一行一个字符串，若所求负环存在，则输出 `YES`，否则输出 `NO`。

**样例输入 #1**

```
2
3 4
1 2 2
1 3 4
2 3 1
3 1 -3
3 3
1 2 3
2 3 4
3 1 -8
```

**样例输出 #1**

```
NO
YES
```



### Bellman-ford判断负环

### SPFA判断负环

~~~c++
#include<bits/stdc++.h>
#define ll long long
#define inf 0x3f3f3f3f

using namespace std;
int t;
int n,m;
struct node
{
	int to;
	int nex;
	int v;
}e[60005];
int head[60005];
int cnt;
void add(int a,int b,int c)
{
	e[++cnt].to=b;
	e[cnt].v=c;
	e[cnt].nex=head[a];
	head[a]=cnt;
}

int d[2005];
int v[2005];
int tim[2005];
int num[2005];
bool flag;
queue<int>q;
void clear(queue<int>& q)
{
	queue<int> empty;
	swap(empty, q);
}
void spfa()
{
	clear(q);
	d[1]=0;
	v[1]=1;
	q.push(1);
	num[1]++;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		v[x]=0;
		for(int i=head[x];i;i=e[i].nex)
		{
			int y=e[i].to;
			int z=e[i].v;
			if(d[y]>d[x]+z)
			{
				d[y]=d[x]+z;
				tim[y]=tim[x]+1;
				if(tim[y]>=n)
				{
					flag=false;
					return;
				}
				if(!v[y])
				{
					q.push(y);
					num[y]++;
					if(num[y]==n)
					{
						flag=false;
						return;
					}
					v[y]=1;
				}
			}
		}
	}
}

int main()
{
	cin>>t;
	while(t--)
	{
		memset(e,0,sizeof(node)*60005);//其实结构体不用初始化也行，只要cnt=0即可
		memset(head,0,sizeof(head));
		memset(d,0x3f,sizeof(d));
		memset(v,0,sizeof(v));
		memset(tim,0,sizeof(tim));
		memset(num,0,sizeof(num));
		flag=true;
		cnt=0;
		cin>>n>>m;
		for(int i=1;i<=m;i++)
		{
			int a,b,c;
			cin>>a>>b>>c;
			if(c>=0)
			{
				add(a,b,c);
				add(b,a,c);
			}
			else
			{
				add(a,b,c);
			}
		}
		spfa();
		if(!flag)
		{
			cout<<"YES"<<endl;
		}
		else cout<<"NO"<<endl;
	}
	return 0;
}
~~~



## 差分约束系统



## *tarjan

~~~c++
#include<bits/stdc++.h>
#define ll long long
#define re register int
using namespace std;
const int maxn=10000+15;

inline ll read()
{
    ll x=0,f=1;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
int n,m,sum,tim,top,s;
int p[maxn],head[maxn],sd[maxn],dfn[maxn],low[maxn];
int stac[maxn],vis[maxn];
int h[maxn],in[maxn],dist[maxn];
struct EDGE
{
    int to,nex,from;
}edge[maxn*10],ed[maxn*10];
void add(int x,int y)
{
    edge[++sum].nex=head[x];
    edge[sum].from=x;
    edge[sum].to=y;
    head[x]=sum;
}
void tarjan(int x)
{
    low[x]=dfn[x]=++tim;
    stac[++top]=x;
    vis[x]=1;
    for(re i=head[x];i;i=edge[i].nex)
    {
        int v=edge[i].to;
        if(!dfn[v])
        {
            tarjan(v);
            low[x]=min(low[x],low[v]);
        }
        else if(vis[v])
        {
            low[x]=min(low[x],low[v]);
        }
    }
    if(dfn[x]==low[x])
    {
        int y;
        while(y=stac[top--])
        {
            sd[y]=x;
            vis[y]=0;
            if(x==y)break;
            p[x]+=p[y];
        }
    }
}

int DP()
{
    queue<int>q;
    int tot=0;
    for(re i=1;i<=n;i++)
    {
        if(sd[i]==i&&!in[i])
        {
            q.push(i);
            dist[i]=p[i];
        }
    }
    while(!q.empty())
    {
        int k=q.front();q.pop();
        for(re i=h[k];i;i=ed[i].nex)
        {
            int v=ed[i].to;
            dist[v]=max(dist[v],dist[k]+p[v]);
            in[v]--;
            if(in[v]==0)q.push(v);
        }
    }
    int ans=0;
    for(re i=1;i<=n;i++)ans=max(ans,dist[i]);
    return ans;
}
int DP2()
{
    queue <int> q;
    int tot=0;
    for (int i=1;i<=n;i++)
    if (sd[i]==i&&!in[i])
    {
        q.push(i);
        dist[i]=p[i];
     } 
    while (!q.empty())
    {
        int k=q.front();q.pop();
        for (int i=h[k];i;i=ed[i].nex)
        {
            int v=ed[i].to;
            dist[v]=max(dist[v],dist[k]+p[v]);
            in[v]--;
            if (in[v]==0) q.push(v);
        }
    }
    int ans=0;
    for (int i=1;i<=n;i++)
    ans=max(ans,dist[i]);
    return ans;
}
int main()
{
    n=read();m=read();
    for(re i=1;i<=n;i++)p[i]=read();
    for(re i=1;i<=m;i++)
    {
        int u=read(),v=read();
        add(u,v);
    }
    for(re i=1;i<=n;i++)
    {
        if(!dfn[i])tarjan(i);
    }
    for(re i=1;i<=m;i++)
    {
        int x=sd[edge[i].from],y=sd[edge[i].to];
        if(x!=y)
        {
            ed[++s].nex=h[x];
            ed[s].to=y;
            ed[s].from=x;
            h[x]=s;
            in[y]++;
        }
    }
    printf("%lld",DP());
    return 0;
}
~~~



## *线段树

~~~~c++
#include<bits/stdc++.h>
#define ll long long
#define inf 0x3f3f3f3f

using namespace std;
ll n,m,mod;
ll a[100005];
struct node
{
	ll add;
	ll mul;
	ll v;
}e[400005];

ll ls(ll x){return x<<1;}
ll rs(ll x){return x<<1|1;}
ll push_up(ll p)
{
	e[p].v=(e[ls(p)].v+e[rs(p)].v)%mod;
}

void build(ll p,ll l,ll r)
{
	e[p].add=0;
	e[p].mul=1;
	if(l==r)
	{
		e[p].v=a[l];
		return;
	}
	ll mid=(l+r)>>1;
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
	push_up(p);
}

void f(ll p,ll l,ll r,ll add,ll mul)
{
	e[p].v=(e[p].v*mul%mod+add*(r-l+1)%mod)%mod;
	
	e[p].mul=(e[p].mul*mul)%mod;
	
	e[p].add=((e[p].add*mul)%mod+add)%mod;
}
void push_down(ll p,ll l,ll r)
{
	ll mid=(l+r)>>1;
	
	f(ls(p),l,mid,e[p].add,e[p].mul);
	f(rs(p),mid+1,r,e[p].add,e[p].mul);
	
	e[p].add=0;
	e[p].mul=1;
}

void add(ll al,ll ar,ll l,ll r,ll p,ll k)
{
	if(l>=al&&r<=ar)
	{
		f(p,l,r,k,1);
		return;
	}
	push_down(p,l,r);
	ll mid=(l+r)>>1;
	if(mid>=al)
	{
		add(al,ar,l,mid,ls(p),k);
	}
	if(mid<ar)
	{
		add(al,ar,mid+1,r,rs(p),k);
	}
	push_up(p);
}
void mul(ll ml,ll mr,ll l,ll r,ll p,ll k)
{
	if(l>=ml&&r<=mr)
	{
		f(p,l,r,0,k);
		return;
	}
	push_down(p,l,r);
	ll mid=(l+r)>>1;
	if(mid>=ml)
	{
		mul(ml,mr,l,mid,ls(p),k);
	}
	if(mid<mr)
	{
		mul(ml,mr,mid+1,r,rs(p),k);
	}
	push_up(p);
}
ll query(ll ql,ll qr,ll l,ll r,ll p)
{
	ll res=0;
	if(l>=ql&&r<=qr)return e[p].v%mod;
	push_down(p,l,r);
	ll mid=(l+r)>>1;
	if(mid>=ql)
	{
		res=(res+query(ql,qr,l,mid,ls(p)))%mod;
	}
	if(mid<qr)
	{
		res=(res+query(ql,qr,mid+1,r,rs(p)))%mod;
	}
	return res%mod;
}


int main()
{
	scanf("%lld%lld%lld",&n,&m,&mod);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
	}
	build(1,1,n);
	
	for(int i=1;i<=m;i++)
	{
		ll v,x,y,k;
		scanf("%lld%lld%lld",&v,&x,&y);
		if(v==1)
		{
			scanf("%lld",&k);
			mul(x,y,1,n,1,k);
		}
		else if(v==2)
		{
			scanf("%lld",&k);
			add(x,y,1,n,1,k);
		}
		else
		{
			printf("%lld\n",query(x,y,1,n,1)%mod);
		}
	}
	return 0;
}
~~~~





## *树链剖分

~~~c++
#include<bits/stdc++.h>
#define ll long long
#define re register int
using namespace std;
const int maxn=30005;
const int inf=900000005;
inline ll read()
{
    ll x=0,f=1;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
    return x*f;
}

ll tot=0;
ll w[maxn],b[maxn],d[maxn],fa[maxn];
ll size[maxn],son[maxn],id[maxn],top[maxn];
struct node
{
    ll nex,to;
}e[maxn<<1];ll head[maxn<<1],cnt=0;
struct dd
{
    ll l,r,sum,maxx;
}t[maxn<<2];
inline void add(ll x,ll y)
{
    e[++cnt].to=y;
    e[cnt].nex=head[x];
    head[x]=cnt;
}
inline void dfs1(ll x,ll f,ll deep)
{
    size[x]=1;
    d[x]=deep;
    fa[x]=f;
    for(re i=head[x];i;i=e[i].nex)
    {
        ll y=e[i].to;
        if(y==f)continue;
        dfs1(y,x,deep+1);
        size[x]+=size[y];
        if(size[son[x]]<size[y])
        {
            son[x]=y;
        }
    }
    return;
}
inline void dfs2(ll x,ll top_)
{
    id[x]=++tot;
    b[tot]=w[x];
    top[x]=top_;
    if(!son[x])return;
    dfs2(son[x],top_);
    for(re i=head[x];i;i=e[i].nex)
    {
        ll y=e[i].to;
        if(!id[y])dfs2(y,y);
    }
    return;
}
inline void push_up(ll x)
{
    t[x].sum=t[x<<1].sum+t[x<<1|1].sum;
    t[x].maxx=max(t[x<<1].maxx,t[x<<1|1].maxx);
}
inline void build(ll x,ll l,ll r)
{
    t[x].l=l;t[x].r=r;
    if(l==r)
    {
        t[x].sum=b[l];
        t[x].maxx=b[l];
        return;//return不能少 
    }
    ll mid=(l+r)>>1;
    build(x<<1,l,mid);
    build(x<<1|1,mid+1,r);
    push_up(x);
    return;
}
inline void tree_change(ll x,ll l,ll r,ll q,ll v)//单点修改 
{
    if(l==r)
    {
        t[x].sum=t[x].maxx=v;
        return;//return不能少 
    }
    ll mid=(l+r)>>1;
    if(q<=mid)tree_change(x<<1,l,mid,q,v);
    else tree_change(x<<1|1,mid+1,r,q,v);
    push_up(x);
}
inline ll querysum(ll x,ll l,ll r)//求新序列 l到r 的区间和 
{
    ll ans=0;
    if(l<=t[x].l&&r>=t[x].r)
    {
        return t[x].sum;//return不能少 
    }
    ll mid=(t[x].l+t[x].r)>>1;
    if(l<=mid)ans+=querysum(x<<1,l,r);
    if(r>mid)ans+=querysum(x<<1|1,l,r);
    //push_up(x);
    return ans;
}
inline ll querymax(ll x,ll l,ll r)//求新序列 l到r 的区间最大值 
{
    ll ans=-inf;
    if(l<=t[x].l&&r>=t[x].r)return t[x].maxx;//return不能少 
    ll mid=(t[x].l+t[x].r)>>1;
    if(l<=mid)ans=max(ans,querymax(x<<1,l,r));
    if(r>mid)ans=max(ans,querymax(x<<1|1,l,r));
    //push_up(x);
    return ans;
}
inline ll tree_sum(ll u,ll v)//求树上节点 u到v 的简单路径节点权值和 
{
    ll ans=0;
    while(top[u]!=top[v])
    {
        if(d[top[u]]<d[top[v]])swap(u,v);
        ans+=querysum(1,id[top[u]],id[u]);
        u=fa[top[u]];
    }
    if(d[u]>d[v])swap(u,v);
    ans+=querysum(1,id[u],id[v]);
    return ans;
}
inline ll tree_max(ll u,ll v)//求树上节点 u到v 的简单路径节点权值最大值
{
    ll ans=-inf;
    while(top[u]!=top[v])
    {
        if(d[top[u]]<d[top[v]])swap(u,v);
        ans=max(ans,querymax(1,id[top[u]],id[u]));
        u=fa[top[u]];
    }
    if(d[u]>d[v])swap(u,v);
    ans=max(ans,querymax(1,id[u],id[v]));
    return ans;
}
ll n,m;
int main()
{
    n=read();
    int x,y;
    for(re i=1;i<n;i++)
    {
        x=read();y=read();
        add(x,y);add(y,x);
    }
    for(re i=1;i<=n;i++)w[i]=read();
    dfs1(1,0,1);//注意先后顺序 
    dfs2(1,1);//注意先后顺序 
    build(1,1,n);//注意先后顺序 
    m=read();
    for(re i=1;i<=m;i++)
    {
        char cxk[10];
        cin>>cxk;
        x=read();y=read();
        if(cxk[1]=='H')
        {
            tree_change(1,1,n,id[x],y);
        }
        else if(cxk[1]=='M')
        {
            printf("%lld\n",tree_max(x,y));
        }
        else if(cxk[1]=='S')
        {
            printf("%lld\n",tree_sum(x,y));
        }
    }
    return 0;
}
~~~



## *二分图匹配

### 二分图判定

### 二分图最大匹配

[二分图讲解](https://www.luogu.com.cn/blog/fusu2333/post-2018-wu-yi-qing-bei-pei-xun-er-fen-tu-xiong-ya-li-suan-fa-post)

**【模板】二分图最大匹配**

[题目链接](https://www.luogu.com.cn/problem/P3386)

**题目描述**

给定一个二分图，其左部点的个数为 n，右部点的个数为 m，边数为 e，求其最大匹配的边数。

左部点从 1 至 n 编号，右部点从 1 至 m 编号。

**输入格式**

输入的第一行是三个整数，分别代表 n，m 和 e。

接下来 e 行，每行两个整数 u, v，表示存在一条连接左部点 u 和右部点 v 的边。

**输出格式**

输出一行一个整数，代表二分图最大匹配的边数。

**样例输入 #1**

```
1 1 1
1 1
```

**样例输出 #1**

```
1
```



**样例输入 #2**

```
4 2 7
3 1
1 2
3 2
1 1
4 2
4 1
1 1
```

**样例输出 #2**

```
2
```



#### 匈牙利算法（增广路算法）

~~~c++
#include<bits/stdc++.h>
#define ll long long
#define inf 0x3f3f3f3f

using namespace std;
int n,m,s;
struct node
{
	int to;
	int nex;
}e[50005];
int head[50005];
int cnt;
void add(int a,int b)
{
	e[++cnt].to=b;
	e[cnt].nex=head[a];
	head[a]=cnt;
}
int v[505];
int match[505];
int ans=0;
bool dfs(int x)
{
	for(int i=head[x];i;i=e[i].nex)
	{
		int y=e[i].to;
		if(!v[y])
		{
			v[y]=1;
			if(!match[y]||dfs(match[y]))
			{
				match[y]=x;
				return true;
			}
		}
	}
	return false;
}

int main()
{
	cin>>n>>m>>s;
	for(int i=1;i<=s;i++)
	{
		int a,b;
		cin>>a>>b;
		add(a,b);
	}
	for(int i=1;i<=n;i++)
	{
		memset(v,0,sizeof(v));
		if(dfs(i))ans++;
	}
	cout<<ans;
	return 0;
}
~~~







## 最大公约数

~~~c++
int gcd(int x,int y)
{return y==0?x:gcd(y,x%y);}
~~~



## 最小公倍数

~~~c++
int lcm(int a,int b)
{
    if (a>b) swap(a,b);
    return a*b/__gcd(a,b);
}
~~~



## 组合数

~~~c++
    从m个数中选n个，一共有多少种方案也就是数学上的C(m,n).
    具体实现：
long long c(long long m,long long n)
{
    long long ans=1;
    for(long long i=m-n+1;i<=m;i++) ans=ans*i/(i-m+n);
    return ans;//边阶乘边相除，可以应付较大的数据↑↑
}
//////////////////////////////////////////////////////////
int c[55][55];
int C(int x,int y)
{
    if(y==1)return x;
    if(x==y)return 1;
    if(y<x-y)return c[x][y]=C(x,x-y);
    if(c[x][y]!=0)
    {
        return c[x][y];
    }
    return c[x][y]=C(x-1,y)+C(x-1,y-1);
}
~~~



## 快速幂

~~~c++
int base=a;
int ans=1;
while(b>0)
{
    if(b&1)ans*=base;
    base*=base;//然后 base 努力上升，他通过自乘一次，使自己变成 a^2。
    b>>=1;
    //它把（二进制的）自己每一位都往右移动了。
    //原来的最后第二位，变成了最后第一位 b = (101)(2进制)。

}
~~~



## 圆周率

~~~c++
const double pi=acos(-1.0);
~~~



## 快速读入

~~~c++
inline ll read()//快读
{
    ll x=0,f=1;
    char c=getchar();
    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
    return x*f;
}
~~~

