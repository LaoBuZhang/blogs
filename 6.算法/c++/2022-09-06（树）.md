# 1.洛谷P5836

[洛谷P5836](https://www.luogu.com.cn/problem/P5836)

题目大意：

求树上两点之间的路径上是否包含指定的节点类型

题目中只用两种类型的节点，其实完全可以扩展为多种类型的节点

并且类型只有两种的话，可以运用并查集O(n)求解：

- 将连通的同一类型的节点放在同一个并查集中，只有当所查询两点是同一连通块且连通块的类型与目标类型不同时输出0。

O(nlogn)思路：lca+dfs

1. num数组记录**任意节点**到**1节点**的路径上某种类型节点的数量，可以通过dfs求出num数组
2. lca求的两个节点的最近公共祖先，运用一个节点的所求类型数量减去公共祖先的所求类型数量求得两节点路径间的的所求类型数量

~~~c++
#include<bits/stdc++.h>
#define ll long long
#define inf 0x3f3f3f3f

using namespace std;
int n,m;
int t;
char s[100005];

struct node
{
	int fro;
	int to;
	int next;
}e[200005];
int head[100005];
int cnt;
void add(int a,int b)
{
	e[++cnt].fro=a;
	e[cnt].to=b;
	e[cnt].next=head[a];
	head[a]=cnt;
}

int ans[100005];

int v[100005];
int num[5][100005];
void dfs(int x)
{
	for(int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if(!v[y])
		{
			v[y]=1;
			if(s[y]=='G')
			{
				num[1][y]=num[1][x]+1;
				num[2][y]=num[2][x];
			}
			else if(s[y]=='H')
			{
				num[2][y]=num[2][x]+1;
				num[1][y]=num[1][x];
			}
			dfs(y);
		}
	}
}

int f[100005][30];
int d[100005];
queue<int>q;
void bfs()
{
	q.push(1);
	d[1]=1;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=e[i].next)
		{
			int y=e[i].to;
			if(d[y])continue;
			d[y]=d[x]+1;
			f[y][0]=x;
			for(int j=1;j<=t;j++)
			{
				f[y][j]=f[f[y][j-1]][j-1];
			}
			q.push(y);
		}
	}
}

int lca(int x,int y)
{
	if(d[x]>d[y])swap(x,y);
	for(int i=t;i>=0;i--)
	{
		if(d[f[y][i]]>=d[x])y=f[y][i];
	}
	if(x==y)
	{
		return x;
	}
	for(int i=t;i>=0;i--)
	{
		if(f[x][i]!=f[y][i])
		{
			x=f[x][i];
			y=f[y][i];
		}
	}
	return f[x][0];
}


int main()
{
	cin>>n>>m;
	t=(int)(log(n)/log(2))+1;
	for(int i=1;i<=n;i++)cin>>s[i];
	for(int i=1;i<n;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		add(a,b);
		add(b,a);
	}
	
	
	if(s[1]=='G')num[1][1]++;
	else if(s[1]=='H')num[2][1]++;
	v[1]=1;
	dfs(1);
	
	bfs();
	
	for(int i=1;i<=m;i++)
	{
		int x,y;
		char z;
		scanf("%d%d",&x,&y);
		cin>>z;
		int mid=lca(x,y);
		if(z=='G')
		{
			int numa=num[1][x]-num[1][mid];
			int numb=num[1][y]-num[1][mid];
			int anss=numa+numb;
			if(s[mid]=='G')anss++;
			if(anss>=1)
			{
				ans[i]=1;
			}
			else
			{
				ans[i]=0;
			}
		}
		else if(z=='H')
		{
			int numa=num[2][x]-num[2][mid];
			int numb=num[2][y]-num[2][mid];
			int anss=numa+numb;
			if(s[mid]=='H')anss++;
			if(anss>=1)
			{
				ans[i]=1;
			}
			else
			{
				ans[i]=0;
			}
		}
	}
	for(int i=1;i<=m;i++)
	{
		cout<<ans[i];
	}
	return 0;
}
~~~





# 2.洛谷P1395

[洛谷P1395](https://www.luogu.com.cn/problem/P1395)

题目大意：

水，树的直径板子题

运用DP做法：

- f[i]代表以i为会议地点时路径长度总和，第一次dfs时可以求出f[1]

- size[x]代表以x为根的子树的大小（节点数量）

- 当前点为x，父节点为fa，则有转移方程

  f[x]=f[fa]+(n-size[x]-1)-(size[x]-1)

  后边两项分别代表x-fa的x一侧的节点数量和fa一侧的节点数量



~~~c++
#include<bits/stdc++.h>
#define ll long long
#define inf 0x3f3f3f3f

using namespace std;
int n;

struct node
{
	int to;
	int next;
}e[100005];
int head[50005];
int cnt;
void add(int a,int b)
{
	e[++cnt].to=b;
	e[cnt].next=head[a];
	head[a]=cnt;
}

int size[50005];
int d[50005];
void dfs1(int x)
{
	size[x]++;
	for(int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if(d[y]==-1)
		{
			d[y]=d[x]+1;
			dfs1(y);
			size[x]+=size[y];
		}
	}
}

int f[50005];
void dfs2(int x,int fa)
{
	f[x]=f[fa]+n-2*size[x];
	for(int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if(y!=fa)
		{
			dfs2(y,x);
		}
	}
}

int main()
{
	cin>>n;
	for(int i=1;i<n;i++)
	{
		int a,b;
		cin>>a>>b;
		add(a,b);
		add(b,a);
	}
	
	for(int i=1;i<=n;i++)d[i]=-1;
	d[1]=0;
	dfs1(1);
	
	int minn=0;
	int ans=1;
	for(int i=1;i<=n;i++)
	{
		minn+=d[i];
	}
	f[1]=minn;
	
	for(int i=head[1];i;i=e[i].next)
	{
		int y=e[i].to;
		dfs2(y,1);
	}
	
	for(int i=1;i<=n;i++)
	{
		if(f[i]<minn)
		{
			minn=f[i];
			ans=i;
		}
	}
	cout<<ans<<" "<<minn;
	return 0;
}
~~~





# 3.洛谷P1099

[洛谷P1099](https://www.luogu.com.cn/problem/P1099)

被卡住了，还没de出来

1，9，10，11，12ac，其他wa